--// Local Chess vs Bot (Legal Moves + Hidden Enemy) by ChatGPT
--// Single LocalScript for executors. You are White; bot is Black (hidden).
--// Features: legal moves (incl. check, castling, en passant, promotion=Q), random bot.
--// Controls: Click your piece, then a target square. Press Delete to clean up.

-- ======= CONFIG =======
local SQUARE_SIZE = 4
local BOARD_Y = 3
local LIGHT = Color3.fromRGB(240,217,181)
local DARK  = Color3.fromRGB(181,136,99)
local MY_COLOR = Color3.fromRGB(255,255,255)   -- White pieces (you)
local HILIGHT_MOVE = Color3.fromRGB(0,255,127)
local BOARD_NAME = "LocalChess_AI_Board"

-- ======= SERVICES =======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()

-- ======= CLEAN OLD =======
pcall(function() local old = workspace:FindFirstChild(BOARD_NAME); if old then old:Destroy() end end)

local BoardFolder = Instance.new("Folder")
BoardFolder.Name = BOARD_NAME
BoardFolder.Parent = workspace

-- Cleanup bind
local cleanupConn
cleanupConn = UIS.InputBegan:Connect(function(io,gpe)
    if gpe then return end
    if io.KeyCode == Enum.KeyCode.Delete then
        if BoardFolder and BoardFolder.Parent then BoardFolder:Destroy() end
        if cleanupConn then cleanupConn:Disconnect() end
    end
end)

-- ======= POSITIONING =======
local function getSpawnCFrame()
    local char = LP.Character or LP.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")
    local forward = hrp.CFrame.LookVector
    local origin = hrp.Position + forward * 12
    return CFrame.new(math.floor(origin.X+0.5), BOARD_Y, math.floor(origin.Z+0.5))
end
local originCF = getSpawnCFrame()

-- Base
local base = Instance.new("Part")
base.Name = "Base"
base.Anchored = true
base.CanCollide = false
base.Material = Enum.Material.SmoothPlastic
base.Color = Color3.fromRGB(90,90,90)
base.Size = Vector3.new(SQUARE_SIZE*8 + 2, 0.2, SQUARE_SIZE*8 + 2)
base.CFrame = originCF + Vector3.new(0, -0.11, 0)
base.Parent = BoardFolder

-- ======= BOARD STATE =======
-- Piece encoding: {c="w"/"b", t="KQRBNP"}; empty = nil
-- Board indices: f=1..8 (A..H), r=1..8 (1..8). White at r=1 (bottom).
local files = {"A","B","C","D","E","F","G","H"}
local function nameSquare(f,r) return files[f]..tostring(r) end

local function clonePiece(p) if not p then return nil end return {c=p.c, t=p.t} end

local board = {}; for f=1,8 do board[f] = {}; end
local sideToMove = "w"
local whiteCastleK, whiteCastleQ = true, true
local blackCastleK, blackCastleQ = true, true
local epSquare = nil  -- {f=,r=} en passant target square
local halfmoveClock = 0
local fullmoveNumber = 1
local gameOver = false

-- Initial setup
local function setupInitial()
    for f=1,8 do
        board[f][2] = {c="w", t="P"}
        board[f][7] = {c="b", t="P"}
    end
    local back = {"R","N","B","Q","K","B","N","R"}
    for f=1,8 do
        board[f][1] = {c="w", t=back[f]}
        board[f][8] = {c="b", t=back[f]}
    end
    sideToMove = "w"
    whiteCastleK, whiteCastleQ = true, true
    blackCastleK, blackCastleQ = true, true
    epSquare = nil
    halfmoveClock = 0
    fullmoveNumber = 1
    gameOver = false
end
setupInitial()

-- ======= RENDER (Squares + My Pieces Only) =======
local squares = {} -- Part grid
local labels  = {} -- TextLabel for my pieces (white)
for f=1,8 do
    squares[f] = {}
    labels[f] = {}
    for r=1,8 do
        local part = Instance.new("Part")
        part.Name = nameSquare(f,r)
        part.Anchored = true
        part.CanCollide = true
        part.Material = Enum.Material.SmoothPlastic
        part.Size = Vector3.new(SQUARE_SIZE, 0.2, SQUARE_SIZE)
        local xOffset = (f-4.5) * SQUARE_SIZE
        local zOffset = (r-4.5) * SQUARE_SIZE
        part.CFrame = originCF * CFrame.new(xOffset, 0, zOffset)
        part.Color = ((f + r) % 2 == 0) and LIGHT or DARK
        part.Parent = BoardFolder
        squares[f][r] = part

        local bb = Instance.new("BillboardGui")
        bb.Name = "PieceBillboard"
        bb.Size = UDim2.new(0, SQUARE_SIZE*10, 0, SQUARE_SIZE*10)
        bb.StudsOffset = Vector3.new(0, 1.5, 0)
        bb.AlwaysOnTop = true
        bb.Adornee = part
        bb.Parent = part

        local tl = Instance.new("TextLabel")
        tl.Size = UDim2.new(1, 0, 1, 0)
        tl.BackgroundTransparency = 1
        tl.TextScaled = true
        tl.Font = Enum.Font.SourceSansBold
        tl.TextColor3 = Color3.new(1,1,1)
        tl.TextStrokeTransparency = 0.4
        tl.Text = ""
        tl.Parent = bb
        labels[f][r] = tl

        -- tiny square name
        local surf = Instance.new("SurfaceGui")
        surf.Face = Enum.NormalId.Top
        surf.CanvasSize = Vector2.new(256,256)
        surf.AlwaysOnTop = true
        surf.Parent = part
        local tiny = Instance.new("TextLabel")
        tiny.BackgroundTransparency = 1
        tiny.Size = UDim2.new(0, 60, 0, 60)
        tiny.Position = UDim2.new(0, 4, 0, 4)
        tiny.Font = Enum.Font.SourceSans
        tiny.TextScaled = true
        tiny.TextColor3 = Color3.fromRGB(30,30,30)
        tiny.Text = part.Name
        tiny.Parent = surf
    end
end

-- Show only my (white) pieces
local WHITE_GLYPH = {K="♔",Q="♕",R="♖",B="♗",N="♘",P="♙"}
local function render()
    for f=1,8 do
        for r=1,8 do
            local p = board[f][r]
            local tl = labels[f][r]
            if p and p.c=="w" then
                tl.Text = WHITE_GLYPH[p.t] or ""
                tl.TextColor3 = MY_COLOR
            else
                tl.Text = "" -- hide black
            end
        end
    end
end
render()

-- Selection and move highlights
local selectBox = Instance.new("SelectionBox")
selectBox.LineThickness = 0.05
selectBox.Color3 = HILIGHT_MOVE
selectBox.Visible = false
selectBox.Parent = BoardFolder

local lastBotFrom, lastBotTo = nil, nil
local function flashBotMove(fr, to)
    if not fr or not to then return end
    local a = Instance.new("SelectionBox")
    a.LineThickness = 0.05; a.Color3 = Color3.fromRGB(255,120,0)
    a.Adornee = squares[fr.f][fr.r]; a.Parent = BoardFolder; a.Visible = true
    local b = Instance.new("SelectionBox")
    b.LineThickness = 0.05; b.Color3 = Color3.fromRGB(255,120,0)
    b.Adornee = squares[to.f][to.r]; b.Parent = BoardFolder; b.Visible = true
    task.delay(0.7, function() pcall(function() a:Destroy() end); pcall(function() b:Destroy() end) end)
end

local function setSelected(fr)
    if fr then
        selectBox.Adornee = squares[fr.f][fr.r]
        selectBox.Visible = true
    else
        selectBox.Visible = false
        selectBox.Adornee = nil
    end
end

-- ======= MOVE GENERATION / RULES =======
local function inBounds(f,r) return f>=1 and f<=8 and r>=1 and r<=8 end
local function kingPos(color)
    for f=1,8 do for r=1,8 do local p=board[f][r]; if p and p.c==color and p.t=="K" then return {f=f,r=r} end end end
    return nil
end

local function isSquareAttackedBy(f,r,attackerColor)
    -- scan directions
    local function anyAt(df,dr, pieces)
        local ff, rr = f+df, r+dr
        while inBounds(ff,rr) do
            local p = board[ff][rr]
            if p then
                if p.c==attackerColor then
                    if pieces[p.t] then return true end
                end
                break
            end
            ff, rr = ff+df, rr+dr
        end
        return false
    end
    -- rook/queen lines
    if anyAt(1,0, {R=true,Q=true}) then return true end
    if anyAt(-1,0,{R=true,Q=true}) then return true end
    if anyAt(0,1, {R=true,Q=true}) then return true end
    if anyAt(0,-1,{R=true,Q=true}) then return true end
    -- bishop/queen diagonals
    if anyAt(1,1,  {B=true,Q=true}) then return true end
    if anyAt(1,-1, {B=true,Q=true}) then return true end
    if anyAt(-1,1, {B=true,Q=true}) then return true end
    if anyAt(-1,-1,{B=true,Q=true}) then return true end
    -- knights
    local kdelta = {{1,2},{2,1},{-1,2},{-2,1},{1,-2},{2,-1},{-1,-2},{-2,-1}}
    for _,d in ipairs(kdelta) do
        local ff, rr = f+d[1], r+d[2]
        if inBounds(ff,rr) then
            local p = board[ff][rr]
            if p and p.c==attackerColor and p.t=="N" then return true end
        end
    end
    -- pawns
    if attackerColor=="w" then
        for _,df in ipairs({-1,1}) do
            local ff, rr = f+df, r-1
            if inBounds(ff,rr) then
                local p = board[ff][rr]; if p and p.c=="w" and p.t=="P" then return true end
            end
        end
    else
        for _,df in ipairs({-1,1}) do
            local ff, rr = f+df, r+1
            if inBounds(ff,rr) then
                local p = board[ff][rr]; if p and p.c=="b" and p.t=="P" then return true end
            end
        end
    end
    -- king adjacents
    for df=-1,1 do for dr=-1,1 do
        if not (df==0 and dr==0) then
            local ff,rr=f+df,r+dr
            if inBounds(ff,rr) then
                local p=board[ff][rr]
                if p and p.c==attackerColor and p.t=="K" then return true end
            end
        end
    end end
    return false
end

local function isInCheck(color)
    local kp = kingPos(color)
    if not kp then return false end
    return isSquareAttackedBy(kp.f, kp.r, color=="w" and "b" or "w")
end

-- Make/Unmake (for testing legality)
local history = {}
local function makeMove(m)
    -- m: {from={f,r}, to={f,r}, piece, capturePiece?, isCastleK?, isCastleQ?, isEP?, promo?}
    local rec = {
        from = {f=m.from.f, r=m.from.r},
        to = {f=m.to.f, r=m.to.r},
        moved = clonePiece(m.piece),
        captured = m.capturePiece and clonePiece(m.capturePiece) or nil,
        prevWCK=whiteCastleK, prevWCQ=whiteCastleQ, prevBCK=blackCastleK, prevBCQ=blackCastleQ,
        prevEP = epSquare and {f=epSquare.f, r=epSquare.r} or nil,
        prevHalf = halfmoveClock, prevSide = sideToMove
    }
    table.insert(history, rec)

    -- move piece
    board[m.to.f][m.to.r] = clonePiece(m.piece)
    board[m.from.f][m.from.r] = nil

    -- en passant capture
    if m.isEP and m.piece.t=="P" and m.captureSquare then
        board[m.captureSquare.f][m.captureSquare.r] = nil
    end

    -- promotion (to Queen)
    if m.promo and board[m.to.f][m.to.r] then
        board[m.to.f][m.to.r].t = m.promo
    end

    -- castling: move rook
    if m.isCastleK then
        if m.piece.c=="w" then
            board[6][1] = board[5][1]; board[5][1] = nil
            board[5][1] = nil
            board[6][1] = {c="w", t="K"}
            board[5][1] = nil
            board[8][1], board[7][1] = nil, {c="w", t="R"}
        else
            board[6][8] = board[5][8]; board[5][8] = nil
            board[8][8], board[7][8] = nil, {c="b", t="R"}
        end
    elseif m.isCastleQ then
        if m.piece.c=="w" then
            board[4][1] = board[5][1]; board[5][1] = nil
            board[1][1], board[3][1] = nil, {c="w", t="R"}
        else
            board[4][8] = board[5][8]; board[5][8] = nil
            board[1][8], board[3][8] = nil, {c="b", t="R"}
        end
    end

    -- update castling rights
    local function touch(f,r, color, typ)
        local p = rec.moved
        if p and p.t=="K" and p.c=="w" then whiteCastleK, whiteCastleQ=false,false end
        if p and p.t=="K" and p.c=="b" then blackCastleK, blackCastleQ=false,false end
        -- if a rook moves or gets captured, remove its side right
        if p and p.t=="R" and p.c=="w" then
            if rec.from.f==1 and rec.from.r==1 then whiteCastleQ=false end
            if rec.from.f==8 and rec.from.r==1 then whiteCastleK=false end
        end
        if p and p.t=="R" and p.c=="b" then
            if rec.from.f==1 and rec.from.r==8 then blackCastleQ=false end
            if rec.from.f==8 and rec.from.r==8 then blackCastleK=false end
        end
        if rec.captured then
            if rec.to.f==1 and rec.to.r==(rec.captured.c=="w" and 1 or 8) and rec.captured.t=="R" then
                if rec.captured.c=="w" then whiteCastleQ=false else blackCastleQ=false end
            end
            if rec.to.f==8 and rec.to.r==(rec.captured.c=="w" and 1 or 8) and rec.captured.t=="R" then
                if rec.captured.c=="w" then whiteCastleK=false else blackCastleK=false end
            end
        end
    end
    touch()

    -- update EP
    epSquare = nil
    if m.piece.t=="P" then
        if math.abs(m.to.r - m.from.r) == 2 then
            epSquare = {f=m.from.f, r=(m.from.r + m.to.r)/2}
        end
    end

    -- halfmove clock
    if m.piece.t=="P" or m.capturePiece then halfmoveClock = 0 else halfmoveClock = halfmoveClock + 1 end
    if sideToMove=="b" then fullmoveNumber = fullmoveNumber + 1 end

    sideToMove = (sideToMove=="w") and "b" or "w"
end

local function unmakeMove()
    local rec = history[#history]; history[#history]=nil
    if not rec then return end
    sideToMove = rec.prevSide
    whiteCastleK, whiteCastleQ = rec.prevWCK, rec.prevWCQ
    blackCastleK, blackCastleQ = rec.prevBCK, rec.prevBCQ
    epSquare = rec.prevEP and {f=rec.prevEP.f, r=rec.prevEP.r} or nil
    halfmoveClock = rec.prevHalf

    -- restore board
    local moved = rec.moved
    local toP = board[rec.to.f][rec.to.r]
    board[rec.from.f][rec.from.r] = clonePiece(moved)
    board[rec.to.f][rec.to.r] = rec.captured and clonePiece(rec.captured) or nil

    -- special cases: EP / castling
    -- Detect EP by mismatch: if moved pawn moved diagonally without captured piece then EP occurred
    if moved.t=="P" and rec.captured and not (rec.to.f==rec.from.f) and not board[rec.to.f][rec.to.r] then
        -- put captured pawn back to its square behind 'to'
        local dir = (moved.c=="w") and -1 or 1
        board[rec.to.f][rec.to.r+dir] = clonePiece(rec.captured)
    end
    -- Castling restore (detect by king 2-square move)
    if moved.t=="K" and math.abs(rec.to.f - rec.from.f) == 2 then
        if moved.c=="w" then
            -- undo rook move
            if rec.to.f==7 then -- king-side
                board[8][1], board[7][1] = {c="w",t="R"}, nil
            else -- queen-side
                board[1][1], board[3][1] = {c="w",t="R"}, nil
            end
        else
            if rec.to.f==7 then
                board[8][8], board[7][8] = {c="b",t="R"}, nil
            else
                board[1][8], board[3][8] = {c="b",t="R"}, nil
            end
        end
    end
end

local function addMove(moves, from, to, piece, capture, extras)
    local m = {from=from, to=to, piece=piece, capturePiece=capture}
    if extras then for k,v in pairs(extras) do m[k]=v end end
    table.insert(moves, m)
end

-- Pseudo-legal moves (not checking king safety yet)
local function genPseudo(color)
    local moves = {}
    local dir = (color=="w") and 1 or -1
    for f=1,8 do for r=1,8 do
        local p = board[f][r]
        if p and p.c==color then
            if p.t=="P" then
                local fr = {f=f,r=r}
                -- forward
                local one = r+dir
                if inBounds(f,one) and not board[f][one] then
                    -- promotion?
                    local promoRank = (color=="w") and 8 or 1
                    if one == promoRank then
                        addMove(moves, fr, {f=f,r=one}, p, nil, {promo="Q"})
                    else
                        addMove(moves, fr, {f=f,r=one}, p, nil)
                        -- double
                        local startRank = (color=="w") and 2 or 7
                        local two = r+2*dir
                        if r==startRank and not board[f][two] then
                            addMove(moves, fr, {f=f,r=two}, p, nil)
                        end
                    end
                end
                -- captures
                for _,df in ipairs({-1,1}) do
                    local ff, rr = f+df, r+dir
                    if inBounds(ff,rr) then
                        local cap = board[ff][rr]
                        if cap and cap.c ~= color then
                            local promoRank = (color=="w") and 8 or 1
                            if rr==promoRank then
                                addMove(moves, fr, {f=ff,r=rr}, p, cap, {promo="Q"})
                            else
                                addMove(moves, fr, {f=ff,r=rr}, p, cap)
                            end
                        end
                    end
                end
                -- en passant
                if epSquare then
                    for _,df in ipairs({-1,1}) do
                        local ff = f+df
                        if ff==epSquare.f and epSquare.r==r+dir then
                            -- capture square is behind ep target
                            local capSq = {f=ff, r=r}
                            local capPiece = board[capSq.f][capSq.r]
                            if capPiece and capPiece.c ~= color and capPiece.t=="P" then
                                addMove(moves, fr, {f=ff,r=r+dir}, p, capPiece, {isEP=true, captureSquare=capSq})
                            end
                        end
                    end
                end
            elseif p.t=="N" then
                local deltas={{1,2},{2,1},{-1,2},{-2,1},{1,-2},{2,-1},{-1,-2},{-2,-1}}
                for _,d in ipairs(deltas) do
                    local ff,rr=f+d[1],r+d[2]
                    if inBounds(ff,rr) then
                        local q=board[ff][rr]
                        if not q or q.c~=color then addMove(moves,{f=f,r=r},{f=ff,r=rr},p,q) end
                    end
                end
            elseif p.t=="B" or p.t=="R" or p.t=="Q" then
                local rays = {}
                if p.t=="B" or p.t=="Q" then
                    table.insert(rays,{1,1}); table.insert(rays,{1,-1}); table.insert(rays,{-1,1}); table.insert(rays,{-1,-1})
                end
                if p.t=="R" or p.t=="Q" then
                    table.insert(rays,{1,0}); table.insert(rays,{-1,0}); table.insert(rays,{0,1}); table.insert(rays,{0,-1})
                end
                for _,d in ipairs(rays) do
                    local ff,rr=f+d[1],r+d[2]
                    while inBounds(ff,rr) do
                        local q=board[ff][rr]
                        if not q then
                            addMove(moves,{f=f,r=r},{f=ff,r=rr},p,nil)
                        else
                            if q.c~=color then addMove(moves,{f=f,r=r},{f=ff,r=rr},p,q) end
                            break
                        end
                        ff,rr=ff+d[1],rr+d[2]
                    end
                end
            elseif p.t=="K" then
                for df=-1,1 do for dr=-1,1 do
                    if not (df==0 and dr==0) then
                        local ff,rr=f+df,r+dr
                        if inBounds(ff,rr) then
                            local q=board[ff][rr]
                            if not q or q.c~=color then addMove(moves,{f=f,r=r},{f=ff,r=rr},p,q) end
                        end
                    end
                end end
                -- castling (pseudo)
                if color=="w" and r==1 and f==5 then
                    if whiteCastleK and not board[6][1] and not board[7][1] then
                        addMove(moves,{f=5,r=1},{f=7,r=1},p,nil,{isCastleK=true})
                    end
                    if whiteCastleQ and not board[4][1] and not board[3][1] and not board[2][1] then
                        addMove(moves,{f=5,r=1},{f=3,r=1},p,nil,{isCastleQ=true})
                    end
                elseif color=="b" and r==8 and f==5 then
                    if blackCastleK and not board[6][8] and not board[7][8] then
                        addMove(moves,{f=5,r=8},{f=7,r=8},p,nil,{isCastleK=true})
                    end
                    if blackCastleQ and not board[4][8] and not board[3][8] and not board[2][8] then
                        addMove(moves,{f=5,r=8},{f=3,r=8},p,nil,{isCastleQ=true})
                    end
                end
            end
        end
    end end
    return moves
end

-- Filter to legal (king not left in check; castling can’t pass/check through attacked squares)
local function legalMoves(color)
    local moves = genPseudo(color)
    local leg = {}
    for _,m in ipairs(moves) do
        -- castle path safety
        local castleOK = true
        if m.isCastleK or m.isCastleQ then
            local r = (color=="w") and 1 or 8
            local midF = m.isCastleK and 6 or 4
            local endF = m.isCastleK and 7 or 3
            -- king cannot be in check, pass through check, or end in check
            if isSquareAttackedBy(5,r, color=="w" and "b" or "w") then castleOK=false end
            if isSquareAttackedBy(midF,r, color=="w" and "b" or "w") then castleOK=false end
            if isSquareAttackedBy(endF,r, color=="w" and "b" or "w") then castleOK=false end
        end
        if not castleOK then goto continue end
        makeMove(m)
        local ok = not isInCheck(color)
        unmakeMove()
        if ok then table.insert(leg, m) end
        ::continue::
    end
    return leg
end

local function hasAnyLegal(color)
    local lm = legalMoves(color)
    return #lm > 0
end

-- ======= TURN / BOT =======
local function resultMessage(text)
    warn("[LocalChess] "..text)
end

local function gameStatusAfter(colorJustMoved)
    local opp = (colorJustMoved=="w") and "b" or "w"
    if isInCheck(opp) then
        if not hasAnyLegal(opp) then
            gameOver = true
            resultMessage((opp=="w" and "White" or "Black").." is checkmated. "..(colorJustMoved=="w" and "White" or "Black").." wins!")
        else
            resultMessage((opp=="w" and "White" or "Black").." is in check.")
        end
    else
        if not hasAnyLegal(opp) then
            gameOver = true
            resultMessage("Stalemate.")
        end
    end
end

local random = Random.new()

local function botMove()
    if gameOver then return end
    if sideToMove ~= "b" then return end
    local moves = legalMoves("b")
    if #moves==0 then
        gameStatusAfter("b")
        render()
        return
    end
    -- simple heuristic: prefer captures; else random
    local caps, noncaps = {}, {}
    for _,m in ipairs(moves) do
        if m.capturePiece then table.insert(caps,m) else table.insert(noncaps,m) end
    end
    local pick
    if #caps>0 then pick = caps[random:NextInteger(1,#caps)] else pick = noncaps[random:NextInteger(1,#noncaps)] end

    -- store bot move from/to for visual flash
    local fromFR = {f=pick.from.f, r=pick.from.r}
    local toFR   = {f=pick.to.f, r=pick.to.r}

    makeMove(pick)
    render()
    flashBotMove(fromFR, toFR)
    gameStatusAfter("b")
end

-- ======= INPUT: SELECT + MOVE =======
local function partToFR(part)
    if not part or not part:IsDescendantOf(BoardFolder) then return nil end
    local n = part.Name
    local fileChar = string.sub(n,1,1)
    local rankNum = tonumber(string.sub(n,2))
    local fIdx
    for i,v in ipairs(files) do if v==fileChar then fIdx=i break end end
    if not fIdx or not rankNum then return nil end
    if fIdx<1 or fIdx>8 or rankNum<1 or rankNum>8 then return nil end
    return {f=fIdx, r=rankNum}
end

local selected = nil

local function onClickSquare(fr)
    if gameOver then return end
    if sideToMove ~= "w" then return end
    if not selected then
        -- select a white piece only
        local p = board[fr.f][fr.r]
        if p and p.c=="w" then
            selected = fr
            setSelected(fr)
        end
    else
        if selected.f==fr.f and selected.r==fr.r then
            selected = nil
            setSelected(nil)
            return
        end
        -- try to find a legal move from selected to fr
        local moves = legalMoves("w")
        local chosen = nil
        for _,m in ipairs(moves) do
            if m.from.f==selected.f and m.from.r==selected.r and m.to.f==fr.f and m.to.r==fr.r then
                chosen = m; break
            end
        end
        if chosen then
            makeMove(chosen)
            selected = nil
            setSelected(nil)
            render()
            gameStatusAfter("w")
            -- bot reply
            task.delay(0.25, botMove)
        else
            -- clicked illegal target; reselect if clicked another white piece
            local p2 = board[fr.f][fr.r]
            if p2 and p2.c=="w" then
                selected = fr
                setSelected(fr)
            else
                -- invalid; deselect
                selected = nil
                setSelected(nil)
            end
        end
    end
end

-- Mouse handler
local clicking = false
Mouse.Button1Down:Connect(function()
    if clicking then return end
    clicking = true
    local part = Mouse.Target
    local fr = partToFR(part)
    if fr then onClickSquare(fr) end
    clicking = false
end)

print("[LocalChess] White vs Bot started. Click a piece, then a square. Bot is hidden. Press Delete to remove.")
render()
