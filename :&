--// Local Chess vs Bot (Executor-Friendly) - Lightweight Blocks + Labels
--// Features:
--//  • Builds its own 8x8 board locally (no game dependencies).
--//  • Shows ONLY your (White) pieces; Black is hidden but fully simulated.
--//  • Legal moves for all pieces (no moving into check).
--//  • Pawn single/double forward, diagonal capture, promotion to Queen.
--//  • Bot auto-moves after you (simple capture-first heuristic).
--//  • Press Delete to clean up.

--==================== CONFIG ====================--
local BOARD_NAME = "ExecChess_LocalBoard"
local SQUARE_SIZE = 4
local BOARD_Y = 3
local LIGHT = Color3.fromRGB(240,217,181)
local DARK  = Color3.fromRGB(181,136,99)
local MY_GLYPH = {K="♔",Q="♕",R="♖",B="♗",N="♘",P="♙"} -- white glyphs
local MY_COLOR = Color3.fromRGB(255,255,255) -- white piece label color
local MOVE_HILITE = Color3.fromRGB(0,255,127)
local BOT_HILITE  = Color3.fromRGB(255,140,0)

--==================== SERVICES ====================--
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local LP = Players.LocalPlayer

--==================== CLEAN OLD ====================--
pcall(function()
    local old = workspace:FindFirstChild(BOARD_NAME)
    if old then old:Destroy() end
end)

local Root = Instance.new("Folder")
Root.Name = BOARD_NAME
Root.Parent = workspace

-- Cleanup keybind
local cleanupConn
cleanupConn = UIS.InputBegan:Connect(function(io, gpe)
    if gpe then return end
    if io.KeyCode == Enum.KeyCode.Delete then
        if Root and Root.Parent then Root:Destroy() end
        if cleanupConn then cleanupConn:Disconnect() end
    end
end)

--==================== POSITIONING ====================--
local function safeGetHRP()
    local char = LP.Character or LP.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    while not hrp do
        char = LP.Character or LP.CharacterAdded:Wait()
        hrp = char:FindFirstChild("HumanoidRootPart")
        RunService.Heartbeat:Wait()
    end
    return hrp
end

local function getSpawnCF()
    local hrp = safeGetHRP()
    local forward = hrp.CFrame.LookVector
    local pos = hrp.Position + forward * 12
    return CFrame.new(math.floor(pos.X+0.5), BOARD_Y, math.floor(pos.Z+0.5))
end

local originCF = getSpawnCF()

-- Base plate (helps clicking)
local Base = Instance.new("Part")
Base.Name = "Base"
Base.Anchored = true
Base.CanCollide = false
Base.Material = Enum.Material.SmoothPlastic
Base.Color = Color3.fromRGB(90,90,90)
Base.Size = Vector3.new(SQUARE_SIZE*8 + 2, 0.2, SQUARE_SIZE*8 + 2)
Base.CFrame = originCF + Vector3.new(0, -0.11, 0)
Base.Parent = Root

--==================== BOARD STATE ====================--
-- board[f][r] = {c="w"/"b", t="KQRBNP"} or nil; files A..H => 1..8; ranks 1..8 (White at r=1)
local files = {"A","B","C","D","E","F","G","H"}
local function sqName(f,r) return files[f]..tostring(r) end
local function inBounds(f,r) return f>=1 and f<=8 and r>=1 and r<=8 end

local board = {}
for f=1,8 do board[f] = {} end

local function setupStart()
    -- Pawns
    for f=1,8 do
        board[f][2] = {c="w", t="P"}
        board[f][7] = {c="b", t="P"}
    end
    -- Back ranks
    local back = {"R","N","B","Q","K","B","N","R"}
    for f=1,8 do
        board[f][1] = {c="w", t=back[f]}
        board[f][8] = {c="b", t=back[f]}
    end
end
setupStart()

local sideToMove = "w"
local gameOver = false
local random = Random.new()

--==================== RENDER (Squares + My Pieces Only) ====================--
local squares = {}  -- Part grid
local labels  = {}  -- TextLabel (for white only)

for f=1,8 do
    squares[f] = {}
    labels[f] = {}
    for r=1,8 do
        local p = Instance.new("Part")
        p.Name = sqName(f,r)
        p.Anchored = true
        p.CanCollide = true
        p.Material = Enum.Material.SmoothPlastic
        p.Size = Vector3.new(SQUARE_SIZE, 0.2, SQUARE_SIZE)
        local x = (f-4.5)*SQUARE_SIZE
        local z = (r-4.5)*SQUARE_SIZE
        p.CFrame = originCF * CFrame.new(x, 0, z)
        p.Color = ((f + r) % 2 == 0) and LIGHT or DARK
        p.Parent = Root
        squares[f][r] = p

        -- piece billboard (white only shown)
        local bb = Instance.new("BillboardGui")
        bb.Name = "Glyph"
        bb.Size = UDim2.new(0, SQUARE_SIZE*10, 0, SQUARE_SIZE*10)
        bb.StudsOffset = Vector3.new(0, 1.5, 0)
        bb.AlwaysOnTop = true
        bb.Adornee = p
        bb.Parent = p

        local tl = Instance.new("TextLabel")
        tl.BackgroundTransparency = 1
        tl.Size = UDim2.new(1,0,1,0)
        tl.TextScaled = true
        tl.Font = Enum.Font.SourceSansBold
        tl.TextColor3 = MY_COLOR
        tl.Text = ""
        tl.Parent = bb
        labels[f][r] = tl

        -- corner label
        local surf = Instance.new("SurfaceGui")
        surf.Face = Enum.NormalId.Top
        surf.CanvasSize = Vector2.new(256,256)
        surf.AlwaysOnTop = true
        surf.Parent = p

        local tiny = Instance.new("TextLabel")
        tiny.BackgroundTransparency = 1
        tiny.Size = UDim2.new(0, 60, 0, 60)
        tiny.Position = UDim2.new(0, 4, 0, 4)
        tiny.Font = Enum.Font.SourceSans
        tiny.TextScaled = true
        tiny.TextColor3 = Color3.fromRGB(30,30,30)
        tiny.Text = p.Name
        tiny.Parent = surf
    end
end

local selectBox = Instance.new("SelectionBox")
selectBox.LineThickness = 0.05
selectBox.Color3 = MOVE_HILITE
selectBox.Visible = false
selectBox.Parent = Root

local function render()
    for f=1,8 do
        for r=1,8 do
            local p = board[f][r]
            local tl = labels[f][r]
            if p and p.c=="w" then
                tl.Text = MY_GLYPH[p.t] or ""
            else
                tl.Text = "" -- hide black pieces
            end
        end
    end
end
render()

--==================== MOVE GENERATION ====================--
local function clonePiece(p) if not p then return nil end return {c=p.c, t=p.t} end

local function kingPos(color)
    for f=1,8 do for r=1,8 do local p=board[f][r]
        if p and p.c==color and p.t=="K" then return {f=f,r=r} end
    end end
    return nil
end

local function isSquareAttackedBy(f,r,att)
    -- Rook/Queen lines
    local function ray(df,dr, allow)
        local ff,rr=f+df,r+dr
        while inBounds(ff,rr) do
            local q = board[ff][rr]
            if q then
                if q.c==att and allow[q.t] then return true end
                return false
            end
            ff,rr=ff+df,rr+dr
        end
        return false
    end
    if ray(1,0,{R=true,Q=true}) then return true end
    if ray(-1,0,{R=true,Q=true}) then return true end
    if ray(0,1,{R=true,Q=true}) then return true end
    if ray(0,-1,{R=true,Q=true}) then return true end
    -- Bishop/Queen diagonals
    if ray(1,1,{B=true,Q=true}) then return true end
    if ray(1,-1,{B=true,Q=true}) then return true end
    if ray(-1,1,{B=true,Q=true}) then return true end
    if ray(-1,-1,{B=true,Q=true}) then return true end
    -- Knights
    local kd={{1,2},{2,1},{-1,2},{-2,1},{1,-2},{2,-1},{-1,-2},{-2,-1}}
    for _,d in ipairs(kd) do
        local ff,rr=f+d[1], r+d[2]
        if inBounds(ff,rr) then
            local q=board[ff][rr]
            if q and q.c==att and q.t=="N" then return true end
        end
    end
    -- Pawns
    if att=="w" then
        for _,df in ipairs({-1,1}) do
            local ff,rr=f+df, r-1
            if inBounds(ff,rr) then
                local q=board[ff][rr]
                if q and q.c=="w" and q.t=="P" then return true end
            end
        end
    else
        for _,df in ipairs({-1,1}) do
            local ff,rr=f+df, r+1
            if inBounds(ff,rr) then
                local q=board[ff][rr]
                if q and q.c=="b" and q.t=="P" then return true end
            end
        end
    end
    -- King adjacent
    for df=-1,1 do for dr=-1,1 do
        if not (df==0 and dr==0) then
            local ff,rr=f+df,r+dr
            if inBounds(ff,rr) then
                local q=board[ff][rr]
                if q and q.c==att and q.t=="K" then return true end
            end
        end
    end end
    return false
end

local function makeMove(m)
    -- m = {from={f,r}, to={f,r}, piece, captured?, promo?}
    local from, to = m.from, m.to
    -- move piece
    board[to.f][to.r] = clonePiece(m.piece)
    board[from.f][from.r] = nil
    -- promotion to Queen
    if m.promo then
        board[to.f][to.r].t = m.promo
    end
    -- return undo record
    return {
        from = {f=from.f,r=from.r},
        to   = {f=to.f, r=to.r},
        movedType = m.piece.t,
        captured  = m.captured and clonePiece(m.captured) or nil
    }
end

local function unmakeMove(rec)
    local moved = board[rec.to.f][rec.to.r]
    board[rec.from.f][rec.from.r] = moved and {c=moved.c, t=rec.movedType} or {c="w",t=rec.movedType} -- restore type
    board[rec.to.f][rec.to.r] = rec.captured and clonePiece(rec.captured) or nil
end

local function add(moves, from, to, piece, captured, promo)
    table.insert(moves, {from=from,to=to,piece=piece,captured=captured,promo=promo})
end

-- Pseudo-legal moves (no self-check test yet)
local function genPseudo(color)
    local moves = {}
    for f=1,8 do for r=1,8 do
        local p = board[f][r]
        if p and p.c==color then
            local from = {f=f,r=r}
            if p.t=="P" then
                local dir = (color=="w") and 1 or -1
                local start = (color=="w") and 2 or 7
                local promoRank = (color=="w") and 8 or 1
                -- forward 1
                local one = r+dir
                if inBounds(f,one) and not board[f][one] then
                    if one==promoRank then
                        add(moves, from, {f=f,r=one}, p, nil, "Q")
                    else
                        add(moves, from, {f=f,r=one}, p, nil, nil)
                        -- forward 2 from start
                        local two = r+2*dir
                        if r==start and not board[f][two] then
                            add(moves, from, {f=f,r=two}, p, nil, nil)
                        end
                    end
                end
                -- captures
                for _,df in ipairs({-1,1}) do
                    local ff,rr=f+df, r+dir
                    if inBounds(ff,rr) then
                        local cap=board[ff][rr]
                        if cap and cap.c~=color then
                            if rr==promoRank then
                                add(moves, from, {f=ff,r=rr}, p, cap, "Q")
                            else
                                add(moves, from, {f=ff,r=rr}, p, cap, nil)
                            end
                        end
                    end
                end
            elseif p.t=="N" then
                local d={{1,2},{2,1},{-1,2},{-2,1},{1,-2},{2,-1},{-1,-2},{-2,-1}}
                for _,v in ipairs(d) do
                    local ff,rr=f+v[1], r+v[2]
                    if inBounds(ff,rr) then
                        local q=board[ff][rr]
                        if not q or q.c~=color then add(moves, from, {f=ff,r=rr}, p, q, nil) end
                    end
                end
            elseif p.t=="B" or p.t=="R" or p.t=="Q" then
                local rays={}
                if p.t~="R" then table.insert(rays,{1,1}); table.insert(rays,{1,-1}); table.insert(rays,{-1,1}); table.insert(rays,{-1,-1}) end
                if p.t~="B" then table.insert(rays,{1,0}); table.insert(rays,{-1,0}); table.insert(rays,{0,1}); table.insert(rays,{0,-1}) end
                for _,d in ipairs(rays) do
                    local ff,rr=f+d[1], r+d[2]
                    while inBounds(ff,rr) do
                        local q=board[ff][rr]
                        if not q then
                            add(moves, from, {f=ff,r=rr}, p, nil, nil)
                        else
                            if q.c~=color then add(moves, from, {f=ff,r=rr}, p, q, nil) end
                            break
                        end
                        ff,rr=ff+d[1], rr+d[2]
                    end
                end
            elseif p.t=="K" then
                for df=-1,1 do for dr=-1,1 do
                    if not (df==0 and dr==0) then
                        local ff,rr=f+df, r+dr
                        if inBounds(ff,rr) then
                            local q=board[ff][rr]
                            if not q or q.c~=color then add(moves, from, {f=ff,r=rr}, p, q, nil) end
                        end
                    end
                end end
            end
        end
    end end
    return moves
end

-- Filter to legal moves (no leaving your king in check)
local function legalMoves(color)
    local ps = genPseudo(color)
    local legal = {}
    for _,m in ipairs(ps) do
        local rec = makeMove(m)
        local kp = kingPos(color)
        local inCheck = false
        if kp then
            inCheck = isSquareAttackedBy(kp.f, kp.r, (color=="w") and "b" or "w")
        else
            inCheck = true
        end
        unmakeMove(rec)
        if not inCheck then table.insert(legal, m) end
    end
    return legal
end

local function anyLegal(color) return #legalMoves(color) > 0 end

--==================== GAME FLOW / BOT ====================--
local function showBotFlash(fromFR, toFR)
    local a = Instance.new("SelectionBox")
    a.LineThickness = 0.05
    a.Color3 = BOT_HILITE
    a.Adornee = squares[fromFR.f][fromFR.r]
    a.Parent = Root
    local b = Instance.new("SelectionBox")
    b.LineThickness = 0.05
    b.Color3 = BOT_HILITE
    b.Adornee = squares[toFR.f][toFR.r]
    b.Parent = Root
    task.delay(0.6, function() pcall(function() a:Destroy() end) pcall(function() b:Destroy() end) end)
end

local function announce(msg) print("[ExecChess] "..msg) end

local function checkEnd(lastMover)
    local opp = (lastMover=="w") and "b" or "w"
    local oppInCheck
    local kp = kingPos(opp)
    if not kp then
        gameOver = true
        announce((lastMover=="w" and "White" or "Black").." wins (king captured).")
        return true
    end
    oppInCheck = isSquareAttackedBy(kp.f, kp.r, (opp=="w") and "b" or "w")
    local hasMoves = anyLegal(opp)
    if oppInCheck and not hasMoves then
        gameOver = true
        announce((opp=="w" and "White" or "Black").." is checkmated. "..(lastMover=="w" and "White" or "Black").." wins!")
        return true
    elseif (not oppInCheck) and (not hasMoves) then
        gameOver = true
        announce("Stalemate.")
        return true
    end
    return false
end

local function botMove()
    if gameOver or sideToMove ~= "b" then return end
    local moves = legalMoves("b")
    if #moves==0 then
        checkEnd("b"); render(); return
    end
    -- Prefer captures a little; else random
    local captures, others = {}, {}
    for _,m in ipairs(moves) do
        if m.captured then table.insert(captures, m) else table.insert(others, m) end
    end
    local pick
    if #captures > 0 then
        pick = captures[random:NextInteger(1, #captures)]
    else
        pick = others[random:NextInteger(1, #others)]
    end

    local fromFR = {f=pick.from.f, r=pick.from.r}
    local toFR   = {f=pick.to.f,   r=pick.to.r}

    makeMove(pick)
    sideToMove = "w"
    render()
    showBotFlash(fromFR, toFR)
    checkEnd("b")
end

--==================== INPUT (CLICK TO MOVE) ====================--
local Mouse = LP:GetMouse()

local function nameToFR(name)
    local file = string.sub(name,1,1)
    local rank = tonumber(string.sub(name,2))
    local fIdx
    for i,v in ipairs(files) do if v==file then fIdx=i break end end
    if not fIdx or not rank then return nil end
    if not inBounds(fIdx, rank) then return nil end
    return {f=fIdx, r=rank}
end

local selected = nil

local function setSelected(fr)
    if fr then
        selectBox.Adornee = squares[fr.f][fr.r]
        selectBox.Visible = true
    else
        selectBox.Adornee = nil
        selectBox.Visible = false
    end
end

local clicking = false
Mouse.Button1Down:Connect(function()
    if clicking then return end
    clicking = true
    local target = Mouse.Target
    if not target or not target:IsDescendantOf(Root) then clicking=false return end
    local fr = nameToFR(target.Name)
    if not fr then clicking=false return end
    if gameOver then clicking=false return end
    if sideToMove ~= "w" then clicking=false return end

    if not selected then
        local p = board[fr.f][fr.r]
        if p and p.c=="w" then
            selected = fr
            setSelected(fr)
        end
    else
        -- same square = deselect
        if selected.f==fr.f and selected.r==fr.r then
            selected = nil
            setSelected(nil)
            clicking=false
            return
        end
        -- try to find a legal move from selected -> fr
        local moves = legalMoves("w")
        local chosen = nil
        for _,m in ipairs(moves) do
            if m.from.f==selected.f and m.from.r==selected.r and m.to.f==fr.f and m.to.r==fr.r then
                chosen = m
                break
            end
        end
        if chosen then
            makeMove(chosen)
            sideToMove = "b"
            selected = nil
            setSelected(nil)
            render()
            if not checkEnd("w") then
                task.delay(0.25, botMove)
            end
        else
            -- reselect if clicked another white piece, else clear
            local p2 = board[fr.f][fr.r]
            if p2 and p2.c=="w" then
                selected = fr
                setSelected(fr)
            else
                selected = nil
                setSelected(nil)
            end
        end
    end
    clicking = false
end)

print("[ExecChess] Ready. You are White. Click a piece, then a square. Bot replies. Press Delete to clean up.")
render()
